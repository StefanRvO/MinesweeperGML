<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>started=0;
//show_message("server");
acc=tcp_listen(12345);
if(socket_has_error(acc))
{
show_message("Can't create server (socketerror)");
//end game
game_end();
}
opponentSocket=-1;
frame=0;
counter=0;
started=1;
nextByteIsHeader = true;
expectedBytes = 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>t=0;
pointX=0;
pointY=0;
randomize();
global.boardx=get_integer("antal felter vandret",5);
global.boardy=get_integer("antal felter lodret",5);
bombs=get_integer("antal bomber",5);
t=1;
//when t is set to 1, we start drawing (in control draw event)

global.flagsPlaced=0;
global.fieldsOpen=0;
opponentBombs=0;
opponentFieldsOpen=0;
opponentFlags=0;
opponentboardx=0;
opponentboardy=0;
restarts=0;
opponentRestarts=0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.fieldsize=20;

//controls size of fileds
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//release port
socket_destroy(acc);
socket_destroy(opponentSocket);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if socket ain't created, create
if(started){
if(opponentSocket &lt; 0) {
    opponentSocket = socket_accept(acc);
    if(opponentSocket &gt; 0) {
        socket_sendbuffer_limit(opponentSocket, 65536);
}
}
else
{
//here we should send values for bombs,flags,and open fields.
//also we should send a message if player loses
write_ubyte(opponentSocket,5);
write_ubyte(opponentSocket,TOTALBOMBS);
write_int(opponentSocket,bombs);

write_ubyte(opponentSocket,5);
write_ubyte(opponentSocket,OPENFIELDS);
write_int(opponentSocket,global.fieldsOpen);

write_ubyte(opponentSocket,5);
write_ubyte(opponentSocket,PLACEDFLAGS);
write_int(opponentSocket,global.flagsPlaced);

write_ubyte(opponentSocket,9);
write_ubyte(opponentSocket,BOARDSIZE);
write_int(opponentSocket,global.boardx);
write_int(opponentSocket,global.boardy);

write_ubyte(opponentSocket,3);
write_ubyte(opponentSocket,RESTARTS);
write_short(opponentSocket,restarts);


socket_send(opponentSocket);
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(started) {
if (opponentSocket &lt;0)
exit;
if(socket_has_error(opponentSocket)) {
    show_message("Lost connection to the client: "+socket_error(opponentSocket));
    game_end();
}

else
{
while(tcp_receive(opponentSocket, expectedBytes)) {
    if(nextByteIsHeader) {
        expectedBytes = read_ubyte(other.opponentSocket);
        nextByteIsHeader = false;
    } else {
        var messageType;
        messageType = read_ubyte(other.opponentSocket);
        switch(messageType) {
        //switchcases depending on messages
        case TOTALBOMBS:
        opponentBombs=read_int(other.opponentSocket);
        break;
        case OPENFIELDS:
        opponentFieldsOpen=read_int(other.opponentSocket);
        break;
        case PLACEDFLAGS:
        opponentFlags=read_int(other.opponentSocket);
        break;
        break;
        case BOARDSIZE:
        opponentboardx=read_int(other.opponentSocket);
        opponentboardy=read_int(other.opponentSocket);
        break;
        case RESTARTS:
        opponentRestarts=read_short(other.opponentSocket);
        break;
        
    
        default:
        //do nothing on unknown
        }
        nextByteIsHeader = true;
        expectedBytes = 1;

        }
        }

//recieve data from the client

}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (t==0) //prevent fault if board isn't generated yet.
//if we got time, we should implent the possabillity to place flags before the board is generated
{
    pointX=floor(mouse_x/global.fieldsize*1.05); //hack to correct a bug somewhere
    pointY=floor(mouse_y/global.fieldsize);
    if (pointX&gt;global.boardx-1 || pointY&gt;global.boardy-1)
    exit;
    //show_message(string(pointX)+" , "+string(pointY));
    //place or remove flag
    ds_grid_create(global.boardx,global.boardy);
            for(i=0;i&lt;global.boardx;i+=1)
            {
                for(j=0;j&lt;global.boardy;j+=1)
                {   
                ds_grid_add(0,i,j,global.bombarray[i,j]);
                }
            }
    clickField(pointX,pointY,1);
    countStats();
    
    for (i=0;i&lt;global.boardx;i+=1)
    {
        for(j=0;j&lt;global.boardy;j+=1)
        {
            global.bombarray[i,j]=ds_grid_get(0,i,j);
        }
    }
    ds_grid_destroy(0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>pointX=floor(mouse_x/global.fieldsize*1.05); //hack to correct a bug somewhere
pointY=floor(mouse_y/global.fieldsize);
if (pointX&gt;global.boardx-1 || pointY&gt;global.boardy-1)
    exit;
if (t)
{
    generateBombPlacement(global.boardx,global.boardy,bombs,pointX,pointY);
    generateBoardNumbers();
    for (i=0;i&lt;global.boardx;i+=1)
    {
        for(j=0;j&lt;global.boardy;j+=1)
        {
            global.bombarray[i,j]=ds_grid_get(0,i,j);
        }
    }
    ds_grid_destroy(0);
    
    for (i=0;i&lt;global.boardx;i+=1)
    {
        for(j=0;j&lt;global.boardy;j+=1)
        {
            instance_create(i*global.fieldsize,j*global.fieldsize,obj_field);
        }
    }
    //don't draw the board anymore. this is now handled by obj_field
    t=0;
}
//show_message(string(pointX)+" , "+string(pointY));
ds_grid_create(global.boardx,global.boardy);
        for(i=0;i&lt;global.boardx;i+=1)
        {
            for(j=0;j&lt;global.boardy;j+=1)
            {   
            ds_grid_add(0,i,j,global.bombarray[i,j]);
            }
        }
        //reset board if we hit a bomb
if(clickField(pointX,pointY,0)==29)
{
    restarts+=1;
    show_message("You hit a bomb, board has been reset");
    t=1;
}
countStats();


for (i=0;i&lt;global.boardx;i+=1)
{
    for(j=0;j&lt;global.boardy;j+=1)
    {
        global.bombarray[i,j]=ds_grid_get(0,i,j);
    }
}
ds_grid_destroy(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw initial board with no open fields
//stop drawing after player has pressed a field
if(t) {
for(i=0;i&lt;global.boardx;i+=1) {
    for (j=0;j&lt;global.boardy;j+=1) {
        draw_sprite(spr_closed,0,global.fieldsize*i,global.fieldsize*j);
        }
    }
}
draw_text(global.fieldsize*global.boardx+40, global.fieldsize*global.boardy+40,"You: open fields: "+string(global.fieldsOpen)+"/"+string(global.boardy*global.boardx-bombs)+"  found bombs: "+string(global.flagsPlaced)+"/"+string(bombs)+ " Restarts: "+string(restarts));
draw_text(global.fieldsize*global.boardx+40, global.fieldsize*global.boardy+60,"opponent: open fields: "+string(opponentFieldsOpen)+"/"+string(opponentboardy*opponentboardx-opponentBombs)+"  found bombs: "+string(opponentFlags)+"/"+string(opponentBombs)+ " Restarts: "+string(opponentRestarts));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="40">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>t = 1;
restarts+=1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsShapePoints/>
</object>
